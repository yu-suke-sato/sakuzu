<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>デジタル作図アプリ</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">

    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: sans-serif;
            background-color: #333;
        }
        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background-color: #ffffff;
            touch-action: none;
        }
        .canvas-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        #bg-canvas { z-index: 1; }
        #main-canvas { z-index: 2; }
        #preview-canvas { z-index: 3; }
        #toolbar {
            position: fixed;
            top: 10px;
            left: 10px;
            z-index: 10;
            background: rgba(240, 240, 240, 0.95);
            border: 1px solid #888;
            border-radius: 8px;
            padding: 10px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            touch-action: manipulation;
            /* (★) スクロールバーを追加 (ボタンが増えたため) */
            max-height: calc(100vh - 40px);
            overflow-y: auto;
        }
        .tool-button,
        .tool-input {
            padding: 8px;
            font-size: 14px;
            border: 1px solid #777;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
            background-color: #fff;
            color: #333;
            text-align: left;
        }
        .tool-button.active {
            background-color: #007bff;
            color: white;
            border-color: #007bff;
            font-weight: bold;
        }
        .tool-button.active-lock {
            background-color: #dc3545; /* 赤色 */
            color: white;
            border-color: #dc3545;
            font-weight: bold;
        }
        .tool-button:hover:not(.active) {
            background-color: #eee;
        }
        #compassModeToggle {
            background-color: #e0e0e0;
            text-align: center;
            font-style: italic;
        }
        #modeToggle {
            background-color: #28a745;
            color: white;
            font-weight: bold;
        }
        #undoButton {
            background-color: #fff0b3;
            font-weight: bold;
            color: #333;
        }
        .separator {
            height: 1px;
            background-color: #ccc;
            margin: 4px 0;
        }
        #fileInput {
            display: none;
        }
        .tool-input label {
            display: block;
            font-size: 12px;
            margin-bottom: 4px;
        }
        .tool-input input[type="range"] {
            width: 100%;
        }
        
        /* ★★★ (新規) カラーパレットのスタイル ★★★ */
        #color-palette {
            display: flex;
            gap: 5px;
            margin-top: 5px;
        }
        .color-button {
            width: 25px;
            height: 25px;
            border: 2px solid #888;
            cursor: pointer;
            padding: 0;
            border-radius: 4px;
            transition: all 0.1s ease;
        }
        .color-button.selected {
            border-color: #007bff; /* 選択中の色を青枠で囲う */
            border-width: 3px;
            transform: scale(1.1); /* 少し大きくする */
        }
        /* ★★★ ここまで ★★★ */

        body.touch-mode #toolbar {
            padding: 12px;
            gap: 12px;
        }
        body.touch-mode .tool-button,
        body.touch-mode .tool-input {
            padding: 16px;
            font-size: 18px;
            font-weight: bold;
        }
        body.touch-mode .tool-input label {
             font-size: 14px;
        }
        /* ★★★ (新規) タッチモード時のカラーボタン ★★★ */
        body.touch-mode .color-button {
            width: 35px;
            height: 35px;
            gap: 8px;
        }
        /* ★★★ ここまで ★★★ */
    </style>
</head>
<body>

    <div id="canvas-container">
        <canvas id="bg-canvas" class="canvas-layer"></canvas>
        <canvas id="main-canvas" class="canvas-layer"></canvas>
        <canvas id="preview-canvas" class="canvas-layer"></canvas>
    </div>

    <div id="toolbar">
        <button id="modeToggle">タッチモードへ</button>
        <div class="separator"></div>

        <button id="compassButton" class="tool-button">1. コンパス</button>
        <button id="compassModeToggle" class="tool-button">1b. 円を描く</button>
        <button id="compassLockRadiusButton" class="tool-button">1c. 半径を固定</button>
        <button id="rulerButton" class="tool-button">2. 定規</button>
        <button id="penButton" class="tool-button">3. ペン</button>
        
        <div class="separator"></div>

        <button id="eraserButton" class="tool-button">4. 消しゴム</button>
        <button id="selectEraseButton" class="tool-button">5. 選択消去</button>
        <button id="clearAllButton" class="tool-button">6. 全消去(描画のみ)</button>
        <button id="undoButton" class="tool-button">元に戻す (Undo)</button>

        <div class="separator"></div>

        <button id="saveFullButton" class="tool-button">7. 全画面保存</button>
        <button id="selectSaveButton" class="tool-button">8. 選択保存</button>
        <button id="loadImageButton" class="tool-button">9. 画像読込(背景)</button>
        <input type="file" id="fileInput" accept="image/*">
        
        <div class="separator"></div>

        <div class="tool-input">
            <label for="lineWidthSlider">線の太さ: <span id="lineWidthValue">5</span>px</label>
            <input type="range" id="lineWidthSlider" min="1" max="100" value="5">
        </div>
        
        <div class="tool-input">
            <label>線の色</label>
            <div id="color-palette">
                <button class="color-button" data-color="#000000" style="background-color: #000000;"></button>
                <button class="color-button" data-color="#FF0000" style="background-color: #FF0000;"></button>
                <button class="color-button" data-color="#0000FF" style="background-color: #0000FF;"></button>
                <button class="color-button" data-color="#008000" style="background-color: #008000;"></button>
                <button class="color-button" data-color="#FFFF00" style="background-color: #FFFF00;"></button>
            </div>
        </div>
        </div>

    <script>
        // --- 1. DOM要素の取得 (変更あり) -------------------------
        const bgCanvas = document.getElementById('bg-canvas');
        const mainCanvas = document.getElementById('main-canvas');
        const previewCanvas = document.getElementById('preview-canvas');

        const bgCtx = bgCanvas.getContext('2d');
        const mainCtx = mainCanvas.getContext('2d'); 
        const previewCtx = previewCanvas.getContext('2d');

        const toolbar = document.getElementById('toolbar');
        const modeToggleButton = document.getElementById('modeToggle');
        const fileInput = document.getElementById('fileInput');
        const lineWidthSlider = document.getElementById('lineWidthSlider');
        const lineWidthValue = document.getElementById('lineWidthValue');
        // (★) lineColorInput を削除
        const compassModeToggleButton = document.getElementById('compassModeToggle');
        const undoButton = document.getElementById('undoButton');
        const compassLockRadiusButton = document.getElementById('compassLockRadiusButton');
        // ★★★ (新規) カラーパレットを取得 ★★★
        const colorPalette = document.getElementById('color-palette');
        // ★★★ ここまで ★★★

        // --- 2. アプリの状態管理 -------------------------
        let isTouchMode = false;
        let currentTool = 'none';
        let isDrawing = false;
        
        let startPos = { x: 0, y: 0 };
        let currentPos = { x: 0, y: 0 };
        let selectionRect = null;
        
        let toolSettings = {
            lineWidth: 5,
            lineColor: '#000000' // デフォルトは黒
        };
        
        let backgroundImage = null;
        
        let tempMainCanvas = document.createElement('canvas');
        let tempMainCtx = tempMainCanvas.getContext('2d');

        // コンパスの状態管理
        let compassState = 'idle'; 
        let compassCenter = null;
        let compassRadius = 0; 
        let compassStartAngle = 0;
        let compassDrawMode = 'arc';
        let isRadiusLocked = false;
        let lockedRadius = 0;
        
        // Undo履歴管理
        let undoHistory = [];
        const MAX_UNDO_STEPS = 20; 


        // --- 3. 初期化処理 (変更あり) -------------------------
        window.addEventListener('load', initialize);
        window.addEventListener('resize', resizeAllCanvas);

        function initialize() {
            setupToolbarListeners(); 
            setupCanvasListeners();
            setupCompassModeToggle();
            setupCompassLockRadiusButton();
            // ★★★ (新規) カラーパレットのリスナーを設定 ★★★
            setupColorPalette();
            // ★★★ ここまで ★★★

            lineWidthSlider.addEventListener('input', (e) => {
                toolSettings.lineWidth = e.target.value;
                lineWidthValue.textContent = e.target.value;
            });
            
            // (★) lineColorInput のリスナーを削除

            if ('ontouchstart' in window) {
                toggleMode(true);
            }
            
            resizeAllCanvas();
            applyToolSettings(mainCtx);
            
            // ★★★ (新規) デフォルトの色（黒）を選択状態にする ★★★
            document.querySelector('.color-button[data-color="#000000"]').classList.add('selected');
        }

        // --- 4. キャンバスリサイズ (変更なし) -------------------------
        function resizeAllCanvas() {
            const dpr = window.devicePixelRatio || 1;
            const rect = document.getElementById('canvas-container').getBoundingClientRect();
            
            if (mainCanvas.width > 0 && mainCanvas.height > 0) {
                 tempMainCanvas.width = mainCanvas.width;
                 tempMainCanvas.height = mainCanvas.height;
                 tempMainCtx.scale(dpr, dpr);
                 tempMainCtx.drawImage(mainCanvas, 0, 0, mainCanvas.width / dpr, mainCanvas.height / dpr);
                 tempMainCtx.setTransform(1, 0, 0, 1, 0, 0); 
            }

            [bgCanvas, mainCanvas, previewCanvas].forEach(canvas => {
                canvas.width = rect.width * dpr;
                canvas.height = rect.height * dpr;
                canvas.style.width = `${rect.width}px`;
                canvas.style.height = `${rect.height}px`;
                
                const ctx = canvas.getContext('2d');
                ctx.scale(dpr, dpr);
            });
            
            applyToolSettings(mainCtx);
            
            if (tempMainCanvas.width > 0) {
                 mainCtx.drawImage(tempMainCanvas, 0, 0, tempMainCanvas.width / dpr, tempMainCanvas.height / dpr);
            }
            
            redrawBgCanvas();
        }
        
        function redrawBgCanvas() {
            const dpr = window.devicePixelRatio || 1;
            bgCtx.clearRect(0, 0, bgCanvas.width / dpr, bgCanvas.height / dpr);
            if (backgroundImage) {
                bgCtx.drawImage(backgroundImage, 0, 0, bgCanvas.width / dpr, bgCanvas.height / dpr);
            }
        }
        
        function applyToolSettings(ctx) {
            ctx.strokeStyle = toolSettings.lineColor;
            ctx.lineWidth = toolSettings.lineWidth;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.globalCompositeOperation = (currentTool === 'eraser') ? 'destination-out' : 'source-over';
        }


        // --- 5. モード切替 (変更なし) -------------------------
        function toggleMode(forceTouch = null) {
            isTouchMode = forceTouch !== null ? forceTouch : !isTouchMode;
            document.body.classList.toggle('touch-mode', isTouchMode);
            modeToggleButton.textContent = isTouchMode ? 'マウスモードへ' : 'タッチモードへ';
        }

        // --- 6. ツールバーのイベントリスナー (変更あり) ----------------
        
        // ★★★ (新規) カラーパレットのリスナー関数 ★★★
        function setupColorPalette() {
            colorPalette.addEventListener('click', (e) => {
                const target = e.target.closest('.color-button');
                if (!target) return;

                // 1. 色を取得
                const newColor = target.dataset.color;
                toolSettings.lineColor = newColor;
                
                // 2. 設定を適用
                applyToolSettings(mainCtx);

                // 3. UIの選択状態を更新
                toolbar.querySelectorAll('.color-button').forEach(btn => {
                    btn.classList.remove('selected');
                });
                target.classList.add('selected');
            });
        }
        // ★★★ ここまで ★★★

        function setupCompassModeToggle() {
            compassModeToggleButton.addEventListener('click', () => {
                if (compassDrawMode === 'arc') {
                    compassDrawMode = 'circle';
                    compassModeToggleButton.textContent = '1b. 弧を描く';
                } else {
                    compassDrawMode = 'arc';
                    compassModeToggleButton.textContent = '1b. 円を描く';
                }
            });
        }
        
        function setupCompassLockRadiusButton() {
            compassLockRadiusButton.addEventListener('click', () => {
                isRadiusLocked = !isRadiusLocked;
                if (isRadiusLocked) {
                    if (compassRadius > 0) {
                        lockedRadius = compassRadius;
                        compassLockRadiusButton.classList.add('active-lock');
                        compassLockRadiusButton.textContent = '1c. 半径解除';
                    } else {
                        isRadiusLocked = false; 
                        alert("先に円か弧を描画して半径を決定してください。");
                    }
                } else {
                    lockedRadius = 0;
                    compassLockRadiusButton.classList.remove('active-lock');
                    compassLockRadiusButton.textContent = '1c. 半径を固定';
                }
            });
        }

        function setupToolbarListeners() {
            modeToggleButton.addEventListener('click', () => toggleMode());
            undoButton.addEventListener('click', undoLastAction);

            toolbar.addEventListener('click', (e) => {
                const target = e.target.closest('button');
                // (変更) カラーボタンは無視
                if (target && target.classList.contains('color-button')) return;
                
                if (!target || target.id === 'compassModeToggle' || target.id === 'modeToggle' || target.id === 'undoButton' || target.id === 'compassLockRadiusButton') return;

                const id = target.id;
                
                if (target.classList.contains('tool-button')) {
                    
                    if (id !== 'compassButton' && compassState !== 'idle') {
                        compassState = 'idle';
                        compassCenter = null;
                        clearPreviewCanvas();
                        isDrawing = false;
                    }

                    switch (id) {
                        case 'penButton': currentTool = 'pen'; break;
                        case 'rulerButton': currentTool = 'ruler'; break;
                        case 'compassButton': currentTool = 'compass'; break;
                        case 'eraserButton': currentTool = 'eraser'; break;
                        case 'selectEraseButton': currentTool = 'selectErase'; break;
                        case 'selectSaveButton': currentTool = 'selectSave'; break;
                        
                        case 'clearAllButton':
                            if (confirm('描画内容をすべて消去しますか？ (背景画像は残ります)')) {
                                saveUndoState();
                                clearMainCanvas();
                            }
                            return; 
                        case 'saveFullButton':
                            saveFullCanvas();
                            return;
                        case 'loadImageButton':
                            fileInput.click();
                            return;
                    }
                    
                    applyToolSettings(mainCtx); 
                    setActiveButton(target);
                }
            });
            
            fileInput.addEventListener('change', handleImageLoad);
        }
        
        function setActiveButton(activeButton) {
            toolbar.querySelectorAll('.tool-button').forEach(btn => {
                if (btn.id !== 'compassModeToggle' && btn.id !== 'modeToggle' && btn.id !== 'undoButton' && btn.id !== 'compassLockRadiusButton') {
                    btn.classList.remove('active');
                }
            });
            if (activeButton) {
                activeButton.classList.add('active');
            }
        }

        // --- 7. キャンバスの描画イベントリスナー (変更なし) ----------------
        
        function setupCanvasListeners() {
            previewCanvas.addEventListener('pointerdown', handlePointerDown);
            previewCanvas.addEventListener('pointermove', handlePointerMove);
            previewCanvas.addEventListener('pointerup', handlePointerUp);
            previewCanvas.addEventListener('pointerleave', handlePointerLeave);
        }

        function handlePointerDown(e) {
            if (toolbar.contains(e.target) || currentTool === 'none') return;
            e.preventDefault();
            const pos = getPosition(e);

            if (currentTool === 'compass') {
                saveUndoState(); 

                if (compassDrawMode === 'circle') {
                    compassCenter = pos;
                    compassState = 'drawingArc';
                    isDrawing = true;
                    startPos = pos;
                    currentPos = pos;
                    if (isRadiusLocked) {
                        compassRadius = lockedRadius; 
                    } else {
                        compassRadius = 0;
                    }
                    clearPreviewCanvas();
                    drawCross(previewCtx, compassCenter, 5, 'black');
                
                } else {
                    if (compassState === 'idle') {
                        compassCenter = pos;
                        compassState = 'centerSet';
                        isDrawing = false;
                        clearPreviewCanvas();
                        drawCross(previewCtx, compassCenter, 5, 'black');
                        return; 
                    }
                    if (compassState === 'centerSet') {
                        isDrawing = true; 
                        startPos = pos; 
                        compassStartAngle = Math.atan2(startPos.y - compassCenter.y, startPos.x - compassCenter.x);
                        compassState = 'drawingArc';
                        currentPos = pos;
                        if (isRadiusLocked) {
                            compassRadius = lockedRadius;
                        } else {
                            compassRadius = Math.hypot(startPos.x - compassCenter.x, startPos.y - compassCenter.y);
                        }
                    }
                }
            } else if (currentTool === 'pen' || currentTool === 'eraser' || currentTool === 'ruler' || currentTool === 'selectErase') {
                saveUndoState();
                isDrawing = true;
                startPos = pos;
                currentPos = pos;
            } else {
                isDrawing = true;
                startPos = pos;
                currentPos = pos;
            }

            selectionRect = null;

            if (currentTool === 'pen' || currentTool === 'eraser') {
                applyToolSettings(mainCtx);
                mainCtx.beginPath();
                mainCtx.moveTo(startPos.x, startPos.y);
            }
        }

        function handlePointerMove(e) {
            if (!isDrawing && (compassDrawMode !== 'arc' || compassState !== 'centerSet')) return;
            e.preventDefault();
            const pos = getPosition(e);

            if (currentTool === 'compass') {
                if (compassDrawMode === 'circle') {
                    if (compassState === 'drawingArc' && isDrawing) {
                        currentPos = pos;
                        let radius;
                        if (isRadiusLocked) {
                            radius = lockedRadius;
                        } else {
                            radius = Math.hypot(currentPos.x - compassCenter.x, currentPos.y - compassCenter.y);
                        }
                        
                        clearPreviewCanvas();
                        drawCross(previewCtx, compassCenter, 5, 'black');
                        drawRadiusLine(previewCtx, compassCenter, currentPos, 'red');
                        drawCircle(previewCtx, compassCenter.x, compassCenter.y, radius, 'red', 1, true);
                        return;
                    }

                } else {
                    if (compassState === 'centerSet') {
                        let previewRadius;
                        if (isRadiusLocked) {
                            previewRadius = lockedRadius;
                        } else {
                            previewRadius = Math.hypot(pos.x - compassCenter.x, pos.y - compassCenter.y);
                        }
                        clearPreviewCanvas();
                        drawCross(previewCtx, compassCenter, 5, 'black');
                        drawRadiusLine(previewCtx, compassCenter, pos, 'red');
                        drawCircle(previewCtx, compassCenter.x, compassCenter.y, previewRadius, 'red', 1, true);
                        return; 
                    }
                    if (compassState === 'drawingArc' && isDrawing) {
                        currentPos = pos;
                        clearPreviewCanvas();
                        
                        drawRadiusLine(previewCtx, compassCenter, startPos, 'red');
                        drawCircle(previewCtx, compassCenter.x, compassCenter.y, compassRadius, 'red', 1, true); 

                        let currentAngle = Math.atan2(currentPos.y - compassCenter.y, currentPos.x - compassCenter.x);
                        
                        let v1_x = startPos.x - compassCenter.x;
                        let v1_y = startPos.y - compassCenter.y;
                        let v2_x = currentPos.x - compassCenter.x;
                        let v2_y = currentPos.y - compassCenter.y;
                        let crossProduct = v1_x * v2_y - v1_y * v2_x;
                        let drawAsCounterClockwise = (crossProduct < 0);
                        
                        previewCtx.beginPath();
                        previewCtx.arc(compassCenter.x, compassCenter.y, compassRadius, compassStartAngle, currentAngle, drawAsCounterClockwise);
                        
                        previewCtx.strokeStyle = toolSettings.lineColor;
                        previewCtx.lineWidth = toolSettings.lineWidth;
                        previewCtx.lineCap = 'round';
                        previewCtx.lineJoin = 'round';
                        previewCtx.globalCompositeOperation = 'source-over';
                        
                        previewCtx.stroke();
                        return; 
                    }
                }
            }
            
            if (isDrawing) {
                currentPos = pos;
                switch (currentTool) {
                    case 'pen':
                    case 'eraser':
                        mainCtx.lineTo(currentPos.x, currentPos.y);
                        mainCtx.stroke();
                        break;
                    case 'ruler': {
                        clearPreviewCanvas();
                        previewCtx.beginPath();
                        previewCtx.moveTo(startPos.x, startPos.y);
                        previewCtx.lineTo(currentPos.x, currentPos.y);
                        applyToolSettings(previewCtx);
                        previewCtx.setLineDash([5, 5]);
                        previewCtx.stroke();
                        previewCtx.setLineDash([]);
                        break;
                    }
                    case 'selectErase':
                    case 'selectSave': {
                        clearPreviewCanvas();
                        previewCtx.strokeStyle = '#007bff';
                        previewCtx.lineWidth = 1;
                        previewCtx.setLineDash([4, 2]);
                        const rect = getRect(startPos, currentPos);
                        previewCtx.strokeRect(rect.x, rect.y, rect.w, rect.h);
                        previewCtx.setLineDash([]);
                        break;
                    }
                }
            }
        }

        function handlePointerUp(e) {
            e.preventDefault();
            
            if (currentTool === 'compass') {
                if (compassDrawMode === 'circle') {
                    if (compassState === 'drawingArc' && isDrawing) {
                        isDrawing = false;
                        const pos = getPosition(e);
                        let finalRadius;
                        
                        if (isRadiusLocked) {
                            finalRadius = lockedRadius;
                        } else {
                            finalRadius = Math.hypot(pos.x - compassCenter.x, pos.y - compassCenter.y);
                            compassRadius = finalRadius; 
                        }
                        
                        clearPreviewCanvas();
                        applyToolSettings(mainCtx); 

                        drawCircle(mainCtx, compassCenter.x, compassCenter.y, finalRadius, toolSettings.lineColor, toolSettings.lineWidth, false);
                        
                        compassState = 'idle';
                        compassCenter = null;
                        return;
                    }

                } else {
                    if (compassState === 'centerSet') {
                        return; 
                    }
                    if (compassState === 'drawingArc' && isDrawing) {
                        isDrawing = false;
                        clearPreviewCanvas();
                        applyToolSettings(mainCtx); 

                        if (!isRadiusLocked) {
                             compassRadius = Math.hypot(startPos.x - compassCenter.x, startPos.y - compassCenter.y);
                        }

                        const pos = getPosition(e);
                        let endAngle = Math.atan2(pos.y - compassCenter.y, pos.x - compassCenter.x);
                        
                        let v1_x = startPos.x - compassCenter.x;
                        let v1_y = startPos.y - compassCenter.y;
                        let v2_x = pos.x - compassCenter.x;
                        let v2_y = pos.y - compassCenter.y;
                        let crossProduct = v1_x * v2_y - v1_y * v2_x;
                        let drawAsCounterClockwise = (crossProduct < 0);

                        mainCtx.beginPath();
                        mainCtx.arc(compassCenter.x, compassCenter.y, compassRadius, compassStartAngle, endAngle, drawAsCounterClockwise);
                        mainCtx.stroke();
                        
                        compassState = 'idle';
                        compassCenter = null;
                        return;
                    }
                }
            }

            if (!isDrawing) return;
            isDrawing = false;
            
            clearPreviewCanvas(); 
            
            switch (currentTool) {
                case 'pen':
                case 'eraser':
                    mainCtx.closePath();
                    break;
                case 'ruler': {
                    applyToolSettings(mainCtx);
                    mainCtx.beginPath();
                    mainCtx.moveTo(startPos.x, startPos.y);
                    mainCtx.lineTo(currentPos.x, currentPos.y);
                    mainCtx.stroke();
                    break;
                }
                case 'selectErase': {
                    selectionRect = getRect(startPos, currentPos);
                    mainCtx.clearRect(selectionRect.x, selectionRect.y, selectionRect.w, selectionRect.h);
                    selectionRect = null;
                    break;
                }
                case 'selectSave': {
                    selectionRect = getRect(startPos, currentPos);
                    saveSelection(selectionRect);
                    selectionRect = null;
                    break;
                }
            }
        }
        
        function handlePointerLeave(e) {
             if (currentTool === 'compass') {
                 if (compassState !== 'idle') {
                     compassState = 'idle';
                     compassCenter = null;
                     isDrawing = false;
                     clearPreviewCanvas();
                     return;
                 }
             }
             if (isDrawing) {
                 handlePointerUp(e);
             }
        }

        // --- 8. 機能別ロジック -------------------------

        function clearMainCanvas() {
            const dpr = window.devicePixelRatio || 1;
            mainCtx.clearRect(0, 0, mainCanvas.width / dpr, mainCanvas.height / dpr);
        }

        function clearPreviewCanvas() {
            const dpr = window.devicePixelRatio || 1;
            previewCtx.clearRect(0, 0, previewCanvas.width / dpr, previewCanvas.height / dpr);
        }

        function drawCircle(ctx, x, y, radius, color, width, isPreview) {
            ctx.beginPath();
            if (radius <= 0) return;
            
            ctx.arc(x, y, radius, 0, Math.PI * 2);
            ctx.strokeStyle = color;
            ctx.lineWidth = width;
            if (isPreview) {
                ctx.setLineDash([5, 5]);
            }
            ctx.stroke();
            if (isPreview) {
                ctx.setLineDash([]);
            }
        }

        function saveFullCanvas() {
            try {
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                
                tempCanvas.width = mainCanvas.width;
                tempCanvas.height = mainCanvas.height;
                
                if (backgroundImage) {
                    tempCtx.drawImage(bgCanvas, 0, 0);
                } else {
                    tempCtx.fillStyle = '#ffffff';
                    tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
                }
                
                tempCtx.drawImage(mainCanvas, 0, 0);
                
                const dataURL = tempCanvas.toDataURL('image/png');
                downloadImage(dataURL, 'my-drawing.png');
                
            } catch (err) {
                console.error("保存に失敗しました:", err);
                alert("画像の保存に失敗しました。");
            }
        }

        function saveSelection(rect) {
            try {
                const dpr = window.devicePixelRatio || 1;
                const imgData = mainCtx.getImageData(rect.x * dpr, rect.y * dpr, rect.w * dpr, rect.h);
                
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = rect.w * dpr;
                tempCanvas.height = rect.h * dpr;
                const tempCtx = tempCanvas.getContext('2d');
                
                tempCtx.putImageData(imgData, 0, 0);
                
                const dataURL = tempCanvas.toDataURL('image/png');
                downloadImage(dataURL, 'selection.png');

            } catch (err) {
                console.error("選択範囲の保存に失敗しました:", err);
                if (err.name === 'SecurityError') {
                     alert("選択範囲の保存に失敗しました。\n\nセキュリティ上の理由により、ローカルファイル(file://)として開いている状態ではこの機能は動作しません。\nWebサーバー経由でアクセスしてください。");
                } else {
                     alert("選択範囲の保存に失敗しました。");
                }
            }
        }
        
        function handleImageLoad(e) {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(event) {
                backgroundImage = new Image();
                backgroundImage.onload = function() {
                    redrawBgCanvas();
                }
                backgroundImage.src = event.target.result;
            }
            reader.readAsDataURL(file);
            
            e.target.value = null; 
        }

        // --- 9. ユーティリティ (ヘルパー関数) -----------------
        function getPosition(e) {
            const rect = previewCanvas.getBoundingClientRect();
            return {
                x: e.clientX - rect.left,
                y: e.clientY - rect.top
            };
        }
        
        function getRect(pos1, pos2) {
            const x = Math.min(pos1.x, pos2.x);
            const y = Math.min(pos1.y, pos2.y);
            const w = Math.abs(pos1.x - pos2.x);
            const h = Math.abs(pos1.y - pos2.y);
            return { x, y, w, h };
        }
        
        function downloadImage(dataURL, filename) {
            const link = document.createElement('a');
            link.href = dataURL;
            link.download = filename;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }
        
        function drawCross(ctx, point, size, color) {
            ctx.beginPath();
            ctx.moveTo(point.x - size, point.y);
            ctx.lineTo(point.x + size, point.y);
            ctx.moveTo(point.x, point.y - size);
            ctx.lineTo(point.x, point.y + size);
            ctx.strokeStyle = color;
            ctx.lineWidth = 1;
            ctx.setLineDash([]);
            ctx.stroke();
        }

        function drawRadiusLine(ctx, center, point, color) {
            ctx.beginPath();
            ctx.moveTo(center.x, center.y);
            ctx.lineTo(point.x, point.y);
            ctx.strokeStyle = color;
            ctx.lineWidth = 1;
            ctx.setLineDash([3, 3]);
            ctx.stroke();
            ctx.setLineDash([]);
        }

        function restoreCanvasState(dataURL) {
            const img = new Image();
            img.onload = function() {
                const dpr = window.devicePixelRatio || 1;
                clearMainCanvas();
                mainCtx.drawImage(img, 0, 0, mainCanvas.width / dpr, mainCanvas.height / dpr);
            }
            img.src = dataURL;
        }

        function saveUndoState() {
            if (undoHistory.length >= MAX_UNDO_STEPS) {
                undoHistory.shift(); 
            }
            undoHistory.push(mainCanvas.toDataURL());
        }

        function undoLastAction() {
            if (undoHistory.length > 0) {
                const stateToRestore = undoHistory.pop();
                restoreCanvasState(stateToRestore);
            } else {
                console.log("これ以上元に戻せません。");
            }
        }
    </script>
</body>
</html>