<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>デジタル作図アプリ</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">

    <style>
        /* (CSSは変更ありません) */
        body {
            margin: 0;
            overflow: hidden;
            font-family: sans-serif;
            background-color: #333;
        }
        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background-color: #ffffff;
            touch-action: none;
        }
        .canvas-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        #bg-canvas { z-index: 1; }
        #main-canvas { z-index: 2; }
        #preview-canvas { z-index: 3; }
        #toolbar {
            position: fixed;
            top: 10px;
            left: 10px;
            z-index: 10;
            background: rgba(240, 240, 240, 0.95);
            border: 1px solid #888;
            border-radius: 8px;
            padding: 10px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            touch-action: manipulation;
        }
        .tool-button,
        .tool-input {
            padding: 8px;
            font-size: 14px;
            border: 1px solid #777;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
            background-color: #fff;
            color: #333;
            text-align: left;
        }
        .tool-button.active {
            background-color: #007bff;
            color: white;
            border-color: #007bff;
            font-weight: bold;
        }
        .tool-button:hover:not(.active) {
            background-color: #eee;
        }
        #compassModeToggle {
            background-color: #e0e0e0;
            text-align: center;
            font-style: italic;
        }
        #modeToggle {
            background-color: #28a745;
            color: white;
            font-weight: bold;
        }
        /* ★「元に戻す」ボタン用のスタイルを追加 ★ */
        #undoButton {
            background-color: #fff0b3;
            font-weight: bold;
            color: #333;
        }
        .separator {
            height: 1px;
            background-color: #ccc;
            margin: 4px 0;
        }
        #fileInput {
            display: none;
        }
        .tool-input label {
            display: block;
            font-size: 12px;
            margin-bottom: 4px;
        }
        .tool-input input[type="range"] {
            width: 100%;
        }
        body.touch-mode #toolbar {
            padding: 12px;
            gap: 12px;
        }
        body.touch-mode .tool-button,
        body.touch-mode .tool-input {
            padding: 16px;
            font-size: 18px;
            font-weight: bold;
        }
        body.touch-mode .tool-input label {
             font-size: 14px;
        }
    </style>
</head>
<body>

    <div id="canvas-container">
        <canvas id="bg-canvas" class="canvas-layer"></canvas>
        <canvas id="main-canvas" class="canvas-layer"></canvas>
        <canvas id="preview-canvas" class="canvas-layer"></canvas>
    </div>

    <div id="toolbar">
        <button id="modeToggle">タッチモードへ</button>
        <div class="separator"></div>

        <button id="compassButton" class="tool-button">1. コンパス</button>
        <button id="compassModeToggle" class="tool-button">1b. 円を描く</button>
        <button id="rulerButton" class="tool-button">2. 定規</button>
        <button id="penButton" class="tool-button active">3. ペン</button>
        
        <div class="separator"></div>

        <button id="eraserButton" class="tool-button">4. 消しゴム</button>
        <button id="selectEraseButton" class="tool-button">5. 選択消去</button>
        <button id="clearAllButton" class="tool-button">6. 全消去(描画のみ)</button>
        
        <button id="undoButton" class="tool-button">元に戻す (Undo)</button>
        <div class="separator"></div>

        <button id="saveFullButton" class="tool-button">7. 全画面保存</button>
        <button id="selectSaveButton" class="tool-button">8. 選択保存</button>
        <button id="loadImageButton" class="tool-button">9. 画像読込(背景)</button>
        <input type="file" id="fileInput" accept="image/*">

        <div class="separator"></div>

        <div class="tool-input">
            <label for="lineWidthSlider">線の太さ: <span id="lineWidthValue">5</span>px</label>
            <input type="range" id="lineWidthSlider" min="1" max="100" value="5">
        </div>
        <div class="tool-input">
            <label for="lineColorInput">線の色</label>
            <input type="color" id="lineColorInput" value="#000000" style="width: 100%; height: 30px; padding: 0;">
        </div>
    </div>

    <script>
        // --- 1. DOM要素の取得 (変更あり) -------------------------
        const bgCanvas = document.getElementById('bg-canvas');
        const mainCanvas = document.getElementById('main-canvas');
        const previewCanvas = document.getElementById('preview-canvas');

        const bgCtx = bgCanvas.getContext('2d');
        const mainCtx = mainCanvas.getContext('2d'); 
        const previewCtx = previewCanvas.getContext('2d');

        const toolbar = document.getElementById('toolbar');
        const modeToggleButton = document.getElementById('modeToggle');
        const fileInput = document.getElementById('fileInput');
        const lineWidthSlider = document.getElementById('lineWidthSlider');
        const lineWidthValue = document.getElementById('lineWidthValue');
        const lineColorInput = document.getElementById('lineColorInput');
        const compassModeToggleButton = document.getElementById('compassModeToggle');
        // ★★★ DOM取得追加 ★★★
        const undoButton = document.getElementById('undoButton');
        // ★★★ ここまで ★★★

        // --- 2. アプリの状態管理 (変更あり) -------------------------
        let isTouchMode = false;
        let currentTool = 'pen';
        let isDrawing = false;
        
        let startPos = { x: 0, y: 0 };
        let currentPos = { x: 0, y: 0 };
        let selectionRect = null;
        
        let toolSettings = {
            lineWidth: 5,
            lineColor: '#000000'
        };
        
        let backgroundImage = null;
        
        let tempMainCanvas = document.createElement('canvas');
        let tempMainCtx = tempMainCanvas.getContext('2d');

        // コンパスの状態管理
        let compassState = 'idle'; 
        let compassCenter = null;
        let compassRadius = 0;
        let compassStartAngle = 0;
        let compassDrawMode = 'arc';
        
        // ★★★ Undo履歴管理の追加 ★★★
        let undoHistory = [];
        const MAX_UNDO_STEPS = 20; // 最大20回まで戻れる
        // ★★★ ここまで ★★★


        // --- 3. 初期化処理 (変更あり) -------------------------
        window.addEventListener('load', initialize);
        window.addEventListener('resize', resizeAllCanvas);

        function initialize() {
            setupToolbarListeners(); // (Undoリスナーもこの中で設定)
            setupCanvasListeners();
            setupCompassModeToggle();

            lineWidthSlider.addEventListener('input', (e) => {
                toolSettings.lineWidth = e.target.value;
                lineWidthValue.textContent = e.target.value;
            });
            lineColorInput.addEventListener('input', (e) => {
                toolSettings.lineColor = e.target.value;
            });

            if ('ontouchstart' in window) {
                toggleMode(true);
            }
            
            resizeAllCanvas();
            setActiveButton(document.getElementById('penButton')); 
            currentTool = 'pen';
            applyToolSettings(mainCtx);
        }

        // --- 4. キャンバスリサイズ (変更なし) -------------------------
        function resizeAllCanvas() {
            const dpr = window.devicePixelRatio || 1;
            const rect = document.getElementById('canvas-container').getBoundingClientRect();
            
            if (mainCanvas.width > 0 && mainCanvas.height > 0) {
                 tempMainCanvas.width = mainCanvas.width;
                 tempMainCanvas.height = mainCanvas.height;
                 tempMainCtx.scale(dpr, dpr);
                 tempMainCtx.drawImage(mainCanvas, 0, 0, mainCanvas.width / dpr, mainCanvas.height / dpr);
                 tempMainCtx.setTransform(1, 0, 0, 1, 0, 0); 
            }

            [bgCanvas, mainCanvas, previewCanvas].forEach(canvas => {
                canvas.width = rect.width * dpr;
                canvas.height = rect.height * dpr;
                canvas.style.width = `${rect.width}px`;
                canvas.style.height = `${rect.height}px`;
                
                const ctx = canvas.getContext('2d');
                ctx.scale(dpr, dpr);
            });
            
            applyToolSettings(mainCtx);
            
            if (tempMainCanvas.width > 0) {
                 mainCtx.drawImage(tempMainCanvas, 0, 0, tempMainCanvas.width / dpr, tempMainCanvas.height / dpr);
            }
            
            redrawBgCanvas();
        }
        
        function redrawBgCanvas() {
            const dpr = window.devicePixelRatio || 1;
            bgCtx.clearRect(0, 0, bgCanvas.width / dpr, bgCanvas.height / dpr);
            if (backgroundImage) {
                bgCtx.drawImage(backgroundImage, 0, 0, bgCanvas.width / dpr, bgCanvas.height / dpr);
            }
        }
        
        function applyToolSettings(ctx) {
            ctx.strokeStyle = toolSettings.lineColor;
            ctx.lineWidth = toolSettings.lineWidth;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.globalCompositeOperation = (currentTool === 'eraser') ? 'destination-out' : 'source-over';
        }


        // --- 5. モード切替 (変更なし) -------------------------
        function toggleMode(forceTouch = null) {
            isTouchMode = forceTouch !== null ? forceTouch : !isTouchMode;
            document.body.classList.toggle('touch-mode', isTouchMode);
            modeToggleButton.textContent = isTouchMode ? 'マウスモードへ' : 'タッチモードへ';
        }

        // --- 6. ツールバーのイベントリスナー (変更あり) ----------------
        
        function setupCompassModeToggle() {
            compassModeToggleButton.addEventListener('click', () => {
                if (compassDrawMode === 'arc') {
                    compassDrawMode = 'circle';
                    compassModeToggleButton.textContent = '1b. 弧を描く';
                } else {
                    compassDrawMode = 'arc';
                    compassModeToggleButton.textContent = '1b. 円を描く';
                }
            });
        }

        function setupToolbarListeners() {
            modeToggleButton.addEventListener('click', () => toggleMode());
            // ★★★ Undoボタンのリスナーを追加 ★★★
            undoButton.addEventListener('click', undoLastAction);
            // ★★★ ここまで ★★★

            toolbar.addEventListener('click', (e) => {
                const target = e.target.closest('button');
                // (変更) Undoボタンも無視
                if (!target || target.id === 'compassModeToggle' || target.id === 'modeToggle' || target.id === 'undoButton') return;

                const id = target.id;
                
                if (target.classList.contains('tool-button')) {
                    
                    if (id !== 'compassButton' && compassState !== 'idle') {
                        compassState = 'idle';
                        compassCenter = null;
                        clearPreviewCanvas();
                        isDrawing = false;
                    }

                    switch (id) {
                        // (変更なし)
                        case 'penButton': currentTool = 'pen'; break;
                        case 'rulerButton': currentTool = 'ruler'; break;
                        case 'compassButton': currentTool = 'compass'; break;
                        case 'eraserButton': currentTool = 'eraser'; break;
                        case 'selectEraseButton': currentTool = 'selectErase'; break;
                        case 'selectSaveButton': currentTool = 'selectSave'; break;
                        
                        case 'clearAllButton':
                            if (confirm('描画内容をすべて消去しますか？ (背景画像は残ります)')) {
                                // ★★★ Undo履歴を保存 ★★★
                                saveUndoState();
                                clearMainCanvas();
                            }
                            return; 
                        case 'saveFullButton':
                            saveFullCanvas();
                            return;
                        case 'loadImageButton':
                            fileInput.click();
                            return;
                    }
                    
                    applyToolSettings(mainCtx); 
                    setActiveButton(target);
                }
            });
            
            fileInput.addEventListener('change', handleImageLoad);
        }
        
        function setActiveButton(activeButton) {
            toolbar.querySelectorAll('.tool-button').forEach(btn => {
                // (変更) Undoボタンは管理外
                if (btn.id !== 'compassModeToggle' && btn.id !== 'modeToggle' && btn.id !== 'undoButton') {
                    btn.classList.remove('active');
                }
            });
            if (activeButton) {
                activeButton.classList.add('active');
            }
        }

        // --- 7. キャンバスの描画イベントリスナー (変更あり) ----------------
        
        function setupCanvasListeners() {
            previewCanvas.addEventListener('pointerdown', handlePointerDown);
            previewCanvas.addEventListener('pointermove', handlePointerMove);
            previewCanvas.addEventListener('pointerup', handlePointerUp);
            previewCanvas.addEventListener('pointerleave', handlePointerLeave);
        }

        function handlePointerDown(e) {
            if (toolbar.contains(e.target)) return;
            e.preventDefault();
            const pos = getPosition(e);

            if (currentTool === 'compass') {
                if (compassDrawMode === 'circle') {
                    // --- 「円」モード (1回ドラッグで描画) ---
                    // ★★★ Undo履歴を保存 ★★★
                    saveUndoState();
                    compassCenter = pos;
                    compassState = 'drawingArc'; 
                    isDrawing = true;
                    startPos = pos;
                    currentPos = pos;
                    compassRadius = 0;
                    clearPreviewCanvas();
                    drawCross(previewCtx, compassCenter, 5, 'black');
                
                } else {
                    // --- 「弧」モード (2回クリックで描画) ---
                    if (compassState === 'idle') {
                        // 1回目 (中心決め) - まだ保存しない
                        compassCenter = pos;
                        compassState = 'centerSet';
                        isDrawing = false;
                        clearPreviewCanvas();
                        drawCross(previewCtx, compassCenter, 5, 'black');
                        return; // 2回目を待つ
                    }
                    if (compassState === 'centerSet') {
                        // 2回目 (半径決め + 描画開始)
                        // ★★★ Undo履歴を保存 ★★★
                        saveUndoState();
                        isDrawing = true; 
                        startPos = pos; 
                        compassRadius = Math.hypot(startPos.x - compassCenter.x, startPos.y - compassCenter.y);
                        compassStartAngle = Math.atan2(startPos.y - compassCenter.y, startPos.x - compassCenter.x);
                        compassState = 'drawingArc';
                        currentPos = pos;
                    }
                }
            } else if (currentTool === 'pen' || currentTool === 'eraser' || currentTool === 'ruler' || currentTool === 'selectErase') {
                 // ★★★ Undo履歴を保存 ★★★
                saveUndoState();
                isDrawing = true;
                startPos = pos;
                currentPos = pos;
            } else {
                // 他のツール (selectSaveなど、履歴不要)
                isDrawing = true;
                startPos = pos;
                currentPos = pos;
            }

            selectionRect = null;

            if (currentTool === 'pen' || currentTool === 'eraser') {
                applyToolSettings(mainCtx);
                mainCtx.beginPath();
                mainCtx.moveTo(startPos.x, startPos.y);
            }
        }

        // (handlePointerMove は変更なし)
        function handlePointerMove(e) {
            if (!isDrawing && (compassDrawMode !== 'arc' || compassState !== 'centerSet')) return;
            e.preventDefault();
            const pos = getPosition(e);

            if (currentTool === 'compass') {
                if (compassDrawMode === 'circle') {
                    if (compassState === 'drawingArc' && isDrawing) {
                        currentPos = pos;
                        let radius = Math.hypot(currentPos.x - compassCenter.x, currentPos.y - compassCenter.y);
                        
                        clearPreviewCanvas();
                        drawCross(previewCtx, compassCenter, 5, 'black');
                        drawRadiusLine(previewCtx, compassCenter, currentPos, 'red');
                        drawCircle(previewCtx, compassCenter.x, compassCenter.y, radius, 'red', 1, true);
                        return;
                    }

                } else {
                    if (compassState === 'centerSet') {
                        clearPreviewCanvas();
                        drawCross(previewCtx, compassCenter, 5, 'black');
                        drawRadiusLine(previewCtx, compassCenter, pos, 'red');
                        return; 
                    }
                    if (compassState === 'drawingArc' && isDrawing) {
                        currentPos = pos;
                        clearPreviewCanvas();
                        
                        drawRadiusLine(previewCtx, compassCenter, startPos, 'red');
                        drawCircle(previewCtx, compassCenter.x, compassCenter.y, compassRadius, 'red', 1, true); 

                        let currentAngle = Math.atan2(currentPos.y - compassCenter.y, currentPos.x - compassCenter.x);
                        
                        let v1_x = startPos.x - compassCenter.x;
                        let v1_y = startPos.y - compassCenter.y;
                        let v2_x = currentPos.x - compassCenter.x;
                        let v2_y = currentPos.y - compassCenter.y;
                        let crossProduct = v1_x * v2_y - v1_y * v2_x;
                        let drawAsCounterClockwise = (crossProduct < 0);
                        
                        previewCtx.beginPath();
                        previewCtx.arc(compassCenter.x, compassCenter.y, compassRadius, compassStartAngle, currentAngle, drawAsCounterClockwise);
                        
                        previewCtx.strokeStyle = toolSettings.lineColor;
                        previewCtx.lineWidth = toolSettings.lineWidth;
                        previewCtx.lineCap = 'round';
                        previewCtx.lineJoin = 'round';
                        previewCtx.globalCompositeOperation = 'source-over';
                        
                        previewCtx.stroke();
                        return; 
                    }
                }
            }
            
            if (isDrawing) {
                currentPos = pos;
                switch (currentTool) {
                    case 'pen':
                    case 'eraser':
                        mainCtx.lineTo(currentPos.x, currentPos.y);
                        mainCtx.stroke();
                        break;
                    case 'ruler': {
                        clearPreviewCanvas();
                        previewCtx.beginPath();
                        previewCtx.moveTo(startPos.x, startPos.y);
                        previewCtx.lineTo(currentPos.x, currentPos.y);
                        applyToolSettings(previewCtx);
                        previewCtx.setLineDash([5, 5]);
                        previewCtx.stroke();
                        previewCtx.setLineDash([]);
                        break;
                    }
                    case 'selectErase':
                    case 'selectSave': {
                        clearPreviewCanvas();
                        previewCtx.strokeStyle = '#007bff';
                        previewCtx.lineWidth = 1;
                        previewCtx.setLineDash([4, 2]);
                        const rect = getRect(startPos, currentPos);
                        previewCtx.strokeRect(rect.x, rect.y, rect.w, rect.h);
                        previewCtx.setLineDash([]);
                        break;
                    }
                }
            }
        }

        // (handlePointerUp は変更なし)
        function handlePointerUp(e) {
            e.preventDefault();
            
            if (currentTool === 'compass') {
                if (compassDrawMode === 'circle') {
                    if (compassState === 'drawingArc' && isDrawing) {
                        isDrawing = false;
                        const pos = getPosition(e);
                        let finalRadius = Math.hypot(pos.x - compassCenter.x, pos.y - compassCenter.y);
                        
                        clearPreviewCanvas();
                        applyToolSettings(mainCtx); 

                        drawCircle(mainCtx, compassCenter.x, compassCenter.y, finalRadius, toolSettings.lineColor, toolSettings.lineWidth, false);
                        
                        compassState = 'idle';
                        compassCenter = null;
                        return;
                    }

                } else {
                    if (compassState === 'centerSet') {
                        return; 
                    }
                    if (compassState === 'drawingArc' && isDrawing) {
                        isDrawing = false;
                        clearPreviewCanvas();
                        applyToolSettings(mainCtx); 

                        const pos = getPosition(e);
                        let endAngle = Math.atan2(pos.y - compassCenter.y, pos.x - compassCenter.x);
                        
                        let v1_x = startPos.x - compassCenter.x;
                        let v1_y = startPos.y - compassCenter.y;
                        let v2_x = pos.x - compassCenter.x;
                        let v2_y = pos.y - compassCenter.y;
                        let crossProduct = v1_x * v2_y - v1_y * v2_x;
                        let drawAsCounterClockwise = (crossProduct < 0);

                        mainCtx.beginPath();
                        mainCtx.arc(compassCenter.x, compassCenter.y, compassRadius, compassStartAngle, endAngle, drawAsCounterClockwise);
                        mainCtx.stroke();
                        
                        compassState = 'idle';
                        compassCenter = null;
                        return;
                    }
                }
            }

            if (!isDrawing) return;
            isDrawing = false;
            
            clearPreviewCanvas(); 
            
            switch (currentTool) {
                case 'pen':
                case 'eraser':
                    mainCtx.closePath();
                    break;
                case 'ruler': {
                    applyToolSettings(mainCtx);
                    mainCtx.beginPath();
                    mainCtx.moveTo(startPos.x, startPos.y);
                    mainCtx.lineTo(currentPos.x, currentPos.y);
                    mainCtx.stroke();
                    break;
                }
                case 'selectErase': {
                    selectionRect = getRect(startPos, currentPos);
                    mainCtx.clearRect(selectionRect.x, selectionRect.y, selectionRect.w, selectionRect.h);
                    selectionRect = null;
                    break;
                }
                case 'selectSave': {
                    selectionRect = getRect(startPos, currentPos);
                    saveSelection(selectionRect);
                    selectionRect = null;
                    break;
                }
            }
        }
        
        // (handlePointerLeave は変更なし)
        function handlePointerLeave(e) {
             if (currentTool === 'compass') {
                 if (compassState !== 'idle') {
                     compassState = 'idle';
                     compassCenter = null;
                     isDrawing = false;
                     clearPreviewCanvas();
                     return;
                 }
             }
             if (isDrawing) {
                 handlePointerUp(e);
             }
        }

        // --- 8. 機能別ロジック (変更なし) -------------------------
        // (clearMainCanvas, clearPreviewCanvas, drawCircle, saveFullCanvas, saveSelection, handleImageLoad)
        function clearMainCanvas() {
            const dpr = window.devicePixelRatio || 1;
            mainCtx.clearRect(0, 0, mainCanvas.width / dpr, mainCanvas.height / dpr);
        }

        function clearPreviewCanvas() {
            const dpr = window.devicePixelRatio || 1;
            previewCtx.clearRect(0, 0, previewCanvas.width / dpr, previewCanvas.height / dpr);
        }

        function drawCircle(ctx, x, y, radius, color, width, isPreview) {
            ctx.beginPath();
            if (radius <= 0) return;
            
            ctx.arc(x, y, radius, 0, Math.PI * 2);
            ctx.strokeStyle = color;
            ctx.lineWidth = width;
            if (isPreview) {
                ctx.setLineDash([5, 5]);
            }
            ctx.stroke();
            if (isPreview) {
                ctx.setLineDash([]);
            }
        }

        function saveFullCanvas() {
            try {
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                
                tempCanvas.width = mainCanvas.width;
                tempCanvas.height = mainCanvas.height;
                
                if (backgroundImage) {
                    tempCtx.drawImage(bgCanvas, 0, 0);
                } else {
                    tempCtx.fillStyle = '#ffffff';
                    tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
                }
                
                tempCtx.drawImage(mainCanvas, 0, 0);
                
                const dataURL = tempCanvas.toDataURL('image/png');
                downloadImage(dataURL, 'my-drawing.png');
                
            } catch (err) {
                console.error("保存に失敗しました:", err);
                alert("画像の保存に失敗しました。");
            }
        }

        function saveSelection(rect) {
            try {
                const dpr = window.devicePixelRatio || 1;
                const imgData = mainCtx.getImageData(rect.x * dpr, rect.y * dpr, rect.w * dpr, rect.h);
                
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = rect.w * dpr;
                tempCanvas.height = rect.h * dpr;
                const tempCtx = tempCanvas.getContext('2d');
                
                tempCtx.putImageData(imgData, 0, 0);
                
                const dataURL = tempCanvas.toDataURL('image/png');
                downloadImage(dataURL, 'selection.png');

            } catch (err) {
                console.error("選択範囲の保存に失敗しました:", err);
                if (err.name === 'SecurityError') {
                     alert("選択範囲の保存に失敗しました。\n\nセキュリティ上の理由により、ローカルファイル(file://)として開いている状態ではこの機能は動作しません。\nWebサーバー経由でアクセスしてください。");
                } else {
                     alert("選択範囲の保存に失敗しました。");
                }
            }
        }
        
        function handleImageLoad(e) {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(event) {
                backgroundImage = new Image();
                backgroundImage.onload = function() {
                    redrawBgCanvas();
                }
                backgroundImage.src = event.target.result;
            }
            reader.readAsDataURL(file);
            
            e.target.value = null; 
        }

        // --- 9. ユーティリティ (ヘルパー関数) (★★ 変更あり ★★) -----------------
        // (getPosition, getRect, downloadImage, drawCross, drawRadiusLine は変更なし)
        function getPosition(e) {
            const rect = previewCanvas.getBoundingClientRect();
            return {
                x: e.clientX - rect.left,
                y: e.clientY - rect.top
            };
        }
        
        function getRect(pos1, pos2) {
            const x = Math.min(pos1.x, pos2.x);
            const y = Math.min(pos1.y, pos2.y);
            const w = Math.abs(pos1.x - pos2.x);
            const h = Math.abs(pos1.y - pos2.y);
            return { x, y, w, h };
        }
        
        function downloadImage(dataURL, filename) {
            const link = document.createElement('a');
            link.href = dataURL;
            link.download = filename;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }
        
        function drawCross(ctx, point, size, color) {
            ctx.beginPath();
            ctx.moveTo(point.x - size, point.y);
            ctx.lineTo(point.x + size, point.y);
            ctx.moveTo(point.x, point.y - size);
            ctx.lineTo(point.x, point.y + size);
            ctx.strokeStyle = color;
            ctx.lineWidth = 1;
            ctx.setLineDash([]);
            ctx.stroke();
        }

        function drawRadiusLine(ctx, center, point, color) {
            ctx.beginPath();
            ctx.moveTo(center.x, center.y);
            ctx.lineTo(point.x, point.y);
            ctx.strokeStyle = color;
            ctx.lineWidth = 1;
            ctx.setLineDash([3, 3]);
            ctx.stroke();
            ctx.setLineDash([]);
        }

        // ★★★「元に戻す」機能の関数を追加 ★★★

        /**
         * (新規) 現在のキャンバス状態を復元する
         */
        function restoreCanvasState(dataURL) {
            const img = new Image();
            img.onload = function() {
                const dpr = window.devicePixelRatio || 1;
                clearMainCanvas();
                // (リサイズされていても、現在のキャンバスサイズに合わせて復元描画する)
                mainCtx.drawImage(img, 0, 0, mainCanvas.width / dpr, mainCanvas.height / dpr);
            }
            img.src = dataURL;
        }

        /**
         * (新規) Undo履歴に現在の状態を保存する
         */
        function saveUndoState() {
            // (将来的にRedoを実装する場合、ここで redoHistory = [] を実行する)

            if (undoHistory.length >= MAX_UNDO_STEPS) {
                undoHistory.shift(); // 古い履歴(配列の先頭)を削除
            }
            // 現在の状態を配列の末尾に追加
            undoHistory.push(mainCanvas.toDataURL());
        }

        /**
         * (新規) 最後の操作を取り消す
         */
        function undoLastAction() {
            if (undoHistory.length > 0) {
                // (将来的にRedoを実装する場合、ここで現在の状態を redoHistory に push する)

                // 最後の履歴を取り出して復元
                const stateToRestore = undoHistory.pop();
                restoreCanvasState(stateToRestore);
            } else {
                console.log("これ以上元に戻せません。");
            }
        }
        // ★★★ ここまで ★★★
    </script>
</body>
</html>