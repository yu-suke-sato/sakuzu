<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>デジタル作図アプリ</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">

    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: sans-serif;
            background-color: #333;
        }
        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background-color: #ffffff;
            touch-action: none;
        }
        .canvas-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        #bg-canvas { z-index: 1; }
        #main-canvas { z-index: 2; }
        #preview-canvas { z-index: 3; }
        #toolbar {
            position: fixed;
            top: 10px;
            left: 10px;
            z-index: 10;
            background: rgba(240, 240, 240, 0.95);
            border: 1px solid #888;
            border-radius: 8px;
            padding: 10px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            touch-action: manipulation;
            max-height: calc(100vh - 40px);
            overflow-y: auto;
        }
        .tool-button,
        .tool-input {
            padding: 8px;
            font-size: 14px;
            border: 1px solid #777;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
            background-color: #fff;
            color: #333;
            text-align: left;
        }
        .tool-button.active {
            background-color: #007bff;
            color: white;
            border-color: #007bff;
            font-weight: bold;
        }
        .tool-button.active-lock {
            background-color: #dc3545; /* 赤色 */
            color: white;
            border-color: #dc3545;
            font-weight: bold;
        }
        .tool-button:hover:not(.active) {
            background-color: #eee;
        }
        /* ★★★ (新規) ペンモード切替ボタン ★★★ */
        #compassModeToggle,
        #penModeToggle {
            background-color: #e0e0e0;
            text-align: center;
            font-style: italic;
        }
        #modeToggle {
            background-color: #28a745;
            color: white;
            font-weight: bold;
        }
        #undoButton {
            background-color: #fff0b3;
            font-weight: bold;
            color: #333;
        }
        #saveStateButton {
            background-color: #cce5ff;
            color: #004085;
            font-weight: bold;
        }
        #loadStateButton {
            background-color: #d4edda;
            color: #155724;
            font-weight: bold;
        }
        #clearStateButton {
            background-color: #f8d7da;
            color: #721c24;
        }
        .separator {
            height: 1px;
            background-color: #ccc;
            margin: 4px 0;
        }
        #fileInput {
            display: none;
        }
        .tool-input label {
            display: block;
            font-size: 12px;
            margin-bottom: 4px;
        }
        .tool-input input[type="range"] {
            width: 100%;
        }
        
        /* カラーパレット */
        #color-palette {
            display: flex;
            gap: 5px;
            margin-top: 5px;
        }
        .color-button {
            width: 25px;
            height: 25px;
            border: 2px solid #888;
            cursor: pointer;
            padding: 0;
            border-radius: 4px;
            transition: all 0.1s ease;
        }
        .color-button.selected {
            border-color: #007bff;
            border-width: 3px;
            transform: scale(1.1);
        }

        body.touch-mode #toolbar {
            padding: 12px;
            gap: 12px;
        }
        body.touch-mode .tool-button,
        body.touch-mode .tool-input {
            padding: 16px;
            font-size: 18px;
            font-weight: bold;
        }
        body.touch-mode .tool-input label {
             font-size: 14px;
        }
        body.touch-mode .color-button {
            width: 35px;
            height: 35px;
            gap: 8px;
        }
    </style>
</head>
<body>

    <div id="canvas-container">
        <canvas id="bg-canvas" class="canvas-layer"></canvas>
        <canvas id="main-canvas" class="canvas-layer"></canvas>
        <canvas id="preview-canvas" class="canvas-layer"></canvas>
    </div>

    <div id="toolbar">
        <button id="modeToggle">タッチモードへ</button>
        <div class="separator"></div>

        <button id="compassButton" class="tool-button">1. コンパス</button>
        <button id="compassModeToggle" class="tool-button">1b. 円を描く</button>
        <button id="compassLockRadiusButton" class="tool-button">1c. 半径を固定</button>
        <button id="rulerButton" class="tool-button">2. 定規</button>
        <button id="penButton" class="tool-button">3. ペン (フリーハンド)</button>
        <button id="penModeToggle" class="tool-button">3b. 点を打つ</button>
        <div class="separator"></div>

        <button id="eraserButton" class="tool-button">4. 消しゴム</button>
        <button id="selectEraseButton" class="tool-button">5. 選択消去</button>
        <button id="clearAllButton" class="tool-button">6. 全消去(描画のみ)</button>
        <button id="undoButton" class="tool-button">元に戻す (Undo)</button>

        <div class="separator"></div>

        <button id="saveFullButton" class="tool-button">7. 全画面保存(画像)</button>
        <button id="loadImageButton" class="tool-button">9. 画像読込(背景)</button>
        <input type="file" id="fileInput" accept="image/*">
        
        <div class="separator"></div>
        
        <button id="saveStateButton" class="tool-button">10. 作業を保存 (PCに)</button>
        <button id="loadStateButton" class="tool-button">11. 作業を読込 (PCから)</button>
        <button id="clearStateButton" class="tool-button">12. 保存を消去</button>

        <div class="separator"></div>

        <div class="tool-input">
            <label for="lineWidthSlider">線の太さ: <span id="lineWidthValue">5</span>px</label>
            <input type="range" id="lineWidthSlider" min="1" max="100" value="5">
        </div>
        
        <div class="tool-input">
            <label>線の色</label>
            <div id="color-palette">
                <button class="color-button" data-color="#000000" style="background-color: #000000;"></button>
                <button class="color-button" data-color="#FF0000" style="background-color: #FF0000;"></button>
                <button class="color-button" data-color="#0000FF" style="background-color: #0000FF;"></button>
                <button class="color-button" data-color="#008000" style="background-color: #008000;"></button>
                <button class="color-button" data-color="#FFFF00" style="background-color: #FFFF00;"></button>
            </div>
        </div>
    </div>

    <script>
        // --- 1. DOM要素の取得 (変更あり) -------------------------
        const bgCanvas = document.getElementById('bg-canvas');
        const mainCanvas = document.getElementById('main-canvas');
        const previewCanvas = document.getElementById('preview-canvas');

        const bgCtx = bgCanvas.getContext('2d');
        const mainCtx = mainCanvas.getContext('2d'); 
        const previewCtx = previewCanvas.getContext('2d');

        const toolbar = document.getElementById('toolbar');
        const modeToggleButton = document.getElementById('modeToggle');
        const fileInput = document.getElementById('fileInput');
        const lineWidthSlider = document.getElementById('lineWidthSlider');
        const lineWidthValue = document.getElementById('lineWidthValue');
        const compassModeToggleButton = document.getElementById('compassModeToggle');
        const undoButton = document.getElementById('undoButton');
        const compassLockRadiusButton = document.getElementById('compassLockRadiusButton');
        const saveStateButton = document.getElementById('saveStateButton');
        const loadStateButton = document.getElementById('loadStateButton');
        const clearStateButton = document.getElementById('clearStateButton');
        const colorPalette = document.getElementById('color-palette');
        // ★★★ (新規) ペンモードボタンを取得 ★★★
        const penModeToggleButton = document.getElementById('penModeToggle');
        // ★★★ ここまで ★★★

        // --- 2. アプリの状態管理 (変更あり) -------------------------
        let isTouchMode = false;
        let currentTool = 'none';
        let isDrawing = false;
        
        let startPos = { x: 0, y: 0 };
        let currentPos = { x: 0, y: 0 };
        let selectionRect = null;
        
        let toolSettings = {
            lineWidth: 5,
            lineColor: '#000000'
        };
        
        let backgroundImage = null;
        
        let tempMainCanvas = document.createElement('canvas');
        let tempMainCtx = tempMainCanvas.getContext('2d');

        // コンパスの状態管理
        let compassState = 'idle'; 
        let compassCenter = null;
        let compassRadius = 0; 
        let compassStartAngle = 0;
        let compassDrawMode = 'arc';
        let isRadiusLocked = false;
        let lockedRadius = 0;
        
        // ★★★ (新規) ペンモードの状態 ★★★
        let penDrawMode = 'freehand'; // 'freehand' または 'point'
        // ★★★ ここまで ★★★
        
        // Undo履歴管理
        let undoHistory = [];
        const MAX_UNDO_STEPS = 20; 

        // LocalStorage用のキー
        const STORAGE_KEY_MAIN = 'digitalDrawingApp_mainCanvas';
        const STORAGE_KEY_BG = 'digitalDrawingApp_bgCanvas';
        // ★★★ (新規) 点の履歴とスナップ設定 ★★★
        const STORAGE_KEY_POINTS = 'digitalDrawingApp_pointsHistory';
        let pointsHistory = []; // {x, y} の配列
        const SNAP_DISTANCE = 15; // 15ピクセル以内ならスナップ
        const POINT_RADIUS = 3; // 描画する点の半径
        // ★★★ ここまで ★★★


        // --- 3. 初期化処理 (変更あり) -------------------------
        window.addEventListener('load', initialize);
        window.addEventListener('resize', resizeAllCanvas);

        function initialize() {
            setupToolbarListeners(); 
            setupCanvasListeners();
            setupCompassModeToggle();
            setupCompassLockRadiusButton();
            setupStateButtons();
            setupColorPalette();
            // ★★★ (新規) ペンモード切替リスナーを設定 ★★★
            setupPenModeToggle();
            // ★★★ ここまで ★★★

            lineWidthSlider.addEventListener('input', (e) => {
                toolSettings.lineWidth = e.target.value;
                lineWidthValue.textContent = e.target.value;
            });

            if ('ontouchstart' in window) {
                toggleMode(true);
            }
            
            resizeAllCanvas();
            applyToolSettings(mainCtx);
            
            document.querySelector('.color-button[data-color="#000000"]').classList.add('selected');
            
            try {
                if (localStorage.getItem(STORAGE_KEY_MAIN)) {
                    if (confirm('以前保存した作業データが見つかりました。読み込みますか？')) {
                        loadStateFromLocalStorage();
                    }
                }
            } catch (e) {
                console.warn("ローカルストレージへのアクセスに失敗しました。", e.message);
            }
        }

        // --- 4. キャンバスリサイズ (変更あり) -------------------------
        function resizeAllCanvas() {
            const dpr = window.devicePixelRatio || 1;
            const rect = document.getElementById('canvas-container').getBoundingClientRect();
            
            // (★) リサイズ時に点の履歴(pointsHistory)は失われるが、
            // (★) Undo/Redoのために、描画内容は一時保存する
            if (mainCanvas.width > 0 && mainCanvas.height > 0) {
                 tempMainCanvas.width = mainCanvas.width;
                 tempMainCanvas.height = mainCanvas.height;
                 tempMainCtx.scale(dpr, dpr);
                 tempMainCtx.drawImage(mainCanvas, 0, 0, mainCanvas.width / dpr, mainCanvas.height / dpr);
                 tempMainCtx.setTransform(1, 0, 0, 1, 0, 0); 
            }

            [bgCanvas, mainCanvas, previewCanvas].forEach(canvas => {
                canvas.width = rect.width * dpr;
                canvas.height = rect.height * dpr;
                canvas.style.width = `${rect.width}px`;
                canvas.style.height = `${rect.height}px`;
                
                const ctx = canvas.getContext('2d');
                ctx.scale(dpr, dpr);
            });
            
            applyToolSettings(mainCtx);
            
            if (tempMainCanvas.width > 0) {
                 mainCtx.drawImage(tempMainCanvas, 0, 0, tempMainCanvas.width / dpr, tempMainCanvas.height / dpr);
            }
            
            redrawBgCanvas();
        }
        
        function redrawBgCanvas() {
            const dpr = window.devicePixelRatio || 1;
            bgCtx.clearRect(0, 0, bgCanvas.width / dpr, bgCanvas.height / dpr);
            if (backgroundImage) {
                bgCtx.drawImage(backgroundImage, 0, 0, bgCanvas.width / dpr, bgCanvas.height / dpr);
            }
        }
        
        function applyToolSettings(ctx) {
            ctx.strokeStyle = toolSettings.lineColor;
            ctx.lineWidth = toolSettings.lineWidth;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.globalCompositeOperation = (currentTool === 'eraser') ? 'destination-out' : 'source-over';
        }


        // --- 5. モード切替 (変更なし) -------------------------
        function toggleMode(forceTouch = null) {
            isTouchMode = forceTouch !== null ? forceTouch : !isTouchMode;
            document.body.classList.toggle('touch-mode', isTouchMode);
            modeToggleButton.textContent = isTouchMode ? 'マウスモードへ' : 'タッチモードへ';
        }

        // --- 6. ツールバーのイベントリスナー (変更あり) ----------------
        
        function setupColorPalette() {
            colorPalette.addEventListener('click', (e) => {
                const target = e.target.closest('.color-button');
                if (!target) return;
                const newColor = target.dataset.color;
                toolSettings.lineColor = newColor;
                applyToolSettings(mainCtx);
                toolbar.querySelectorAll('.color-button').forEach(btn => {
                    btn.classList.remove('selected');
                });
                target.classList.add('selected');
            });
        }

        // ★★★ (新規) ペンモード切替 ★★★
        function setupPenModeToggle() {
            penModeToggleButton.addEventListener('click', () => {
                if (penDrawMode === 'freehand') {
                    penDrawMode = 'point';
                    penModeToggleButton.textContent = '3b. フリーハンド';
                } else {
                    penDrawMode = 'freehand';
                    penModeToggleButton.textContent = '3b. 点を打つ';
                }
                // (★) ペンモード切替と同時に「ペン」ツールを選択状態にする
                currentTool = 'pen';
                setActiveButton(document.getElementById('penButton'));
            });
        }
        // ★★★ ここまで ★★★

        function setupCompassModeToggle() {
            compassModeToggleButton.addEventListener('click', () => {
                if (compassDrawMode === 'arc') {
                    compassDrawMode = 'circle';
                    compassModeToggleButton.textContent = '1b. 弧を描く';
                } else {
                    compassDrawMode = 'arc';
                    compassModeToggleButton.textContent = '1b. 円を描く';
                }
            });
        }
        
        function setupCompassLockRadiusButton() {
            compassLockRadiusButton.addEventListener('click', () => {
                isRadiusLocked = !isRadiusLocked;
                if (isRadiusLocked) {
                    if (compassRadius > 0) {
                        lockedRadius = compassRadius;
                        compassLockRadiusButton.classList.add('active-lock');
                        compassLockRadiusButton.textContent = '1c. 半径解除';
                    } else {
                        isRadiusLocked = false; 
                        alert("先に円か弧を描画して半径を決定してください。");
                    }
                } else {
                    lockedRadius = 0;
                    compassLockRadiusButton.classList.remove('active-lock');
                    compassLockRadiusButton.textContent = '1c. 半径を固定';
                }
            });
        }
        
        function setupStateButtons() {
            saveStateButton.addEventListener('click', saveStateToLocalStorage);
            loadStateButton.addEventListener('click', loadStateFromLocalStorage);
            clearStateButton.addEventListener('click', clearStateFromLocalStorage);
        }

        function setupToolbarListeners() {
            modeToggleButton.addEventListener('click', () => toggleMode());
            undoButton.addEventListener('click', undoLastAction);

            toolbar.addEventListener('click', (e) => {
                if (e.target.classList.contains('color-button')) return;
                
                const target = e.target.closest('button');
                // (★) 無視リストに penModeToggle を追加
                const ignoreList = ['compassModeToggle', 'penModeToggle', 'modeToggle', 'undoButton', 'compassLockRadiusButton', 'saveStateButton', 'loadStateButton', 'clearStateButton'];
                if (!target || ignoreList.includes(target.id)) return;

                const id = target.id;
                
                if (target.classList.contains('tool-button')) {
                    
                    if (id !== 'compassButton' && compassState !== 'idle') {
                        compassState = 'idle';
                        compassCenter = null;
                        clearPreviewCanvas();
                        isDrawing = false;
                    }

                    switch (id) {
                        case 'penButton': currentTool = 'pen'; break;
                        case 'rulerButton': currentTool = 'ruler'; break;
                        case 'compassButton': currentTool = 'compass'; break;
                        case 'eraserButton': currentTool = 'eraser'; break;
                        case 'selectEraseButton': currentTool = 'selectErase'; break;
                        // (★) selectSaveButton を削除
                        
                        case 'clearAllButton':
                            if (confirm('描画内容をすべて消去しますか？ (背景画像は残ります)')) {
                                saveUndoState();
                                clearMainCanvas();
                                pointsHistory = []; // (★) 点の履歴もクリア
                            }
                            return; 
                        case 'saveFullButton':
                            saveFullCanvas();
                            return;
                        case 'loadImageButton':
                            fileInput.click();
                            return;
                    }
                    
                    applyToolSettings(mainCtx); 
                    setActiveButton(target);
                }
            });
            
            fileInput.addEventListener('change', handleImageLoad);
        }
        
        function setActiveButton(activeButton) {
            toolbar.querySelectorAll('.tool-button').forEach(btn => {
                // (★) 無視リストに penModeToggle を追加
                const ignoreList = ['compassModeToggle', 'penModeToggle', 'modeToggle', 'undoButton', 'compassLockRadiusButton', 'saveStateButton', 'loadStateButton', 'clearStateButton'];
                if (!ignoreList.includes(btn.id)) {
                    btn.classList.remove('active');
                }
            });
            if (activeButton) {
                activeButton.classList.add('active');
            }
        }

        // --- 7. キャンバスの描画イベントリスナー (★★ 修正 ★★) ----------------
        
        function setupCanvasListeners() {
            previewCanvas.addEventListener('pointerdown', handlePointerDown);
            previewCanvas.addEventListener('pointermove', handlePointerMove);
            previewCanvas.addEventListener('pointerup', handlePointerUp);
            previewCanvas.addEventListener('pointerleave', handlePointerLeave);
        }

        function handlePointerDown(e) {
            if (toolbar.contains(e.target) || currentTool === 'none') return;
            e.preventDefault();
            const pos = getPosition(e);
            
            // ★★★ (新規) 「点を打つ」ロジック ★★★
            if (currentTool === 'pen' && penDrawMode === 'point') {
                saveUndoState();
                const pointPos = getSnappedPoint(pos); // (★) 点を打つときもスナップ
                drawPoint(mainCtx, pointPos); // メインキャンバスに点を描画
                pointsHistory.push(pointPos); // 履歴に追加
                isDrawing = false; // 点はドラッグしない
                return;
            }
            // ★★★ ここまで ★★★

            // (★) 定規モード、コンパスモード(中心決め)のスナップ処理
            let snappedStartPos = pos;
            if (currentTool === 'ruler' || (currentTool === 'compass' && compassState === 'idle')) {
                snappedStartPos = getSnappedPoint(pos);
            }
            startPos = snappedStartPos;


            if (currentTool === 'compass') {
                saveUndoState(); 

                if (compassDrawMode === 'circle') {
                    compassCenter = startPos;
                    compassState = 'drawingArc';
                    isDrawing = true;
                    currentPos = startPos;
                    if (isRadiusLocked) {
                        compassRadius = lockedRadius; 
                    } else {
                        compassRadius = 0;
                    }
                    clearPreviewCanvas();
                    drawCross(previewCtx, compassCenter, 5, 'black');
                
                } else {
                    if (compassState === 'idle') {
                        compassCenter = startPos;
                        compassState = 'centerSet';
                        isDrawing = false;
                        clearPreviewCanvas();
                        drawCross(previewCtx, compassCenter, 5, 'black');
                        return; 
                    }
                    if (compassState === 'centerSet') {
                        isDrawing = true; 
                        // (★) 2点目もスナップする
                        startPos = getSnappedPoint(pos); 
                        compassStartAngle = Math.atan2(startPos.y - compassCenter.y, startPos.x - compassCenter.x);
                        compassState = 'drawingArc';
                        currentPos = startPos;
                        if (isRadiusLocked) {
                            compassRadius = lockedRadius;
                        } else {
                            compassRadius = Math.hypot(startPos.x - compassCenter.x, startPos.y - compassCenter.y);
                        }
                    }
                }
            } else if (currentTool === 'pen' || currentTool === 'eraser' || currentTool === 'ruler' || currentTool === 'selectErase') {
                saveUndoState();
                isDrawing = true;
                currentPos = startPos;
            } else {
                // (selectSave は削除された)
                isDrawing = true;
                currentPos = startPos;
            }

            selectionRect = null;

            // (★) penDrawMode === 'freehand' の場合のみ実行
            if ((currentTool === 'pen' && penDrawMode === 'freehand') || currentTool === 'eraser') {
                applyToolSettings(mainCtx);
                mainCtx.beginPath();
                mainCtx.moveTo(startPos.x, startPos.y);
            }
        }

        function handlePointerMove(e) {
            // (★) 定規モードは常にスナップチェックするため、isDrawingがfalseでも動かす
            if (!isDrawing && (compassDrawMode !== 'arc' || compassState !== 'centerSet') && (currentTool !== 'ruler')) return;
            e.preventDefault();
            const pos = getPosition(e);
            
            // ★★★ (新規) 定規モードのスナップ処理 ★★★
            if (currentTool === 'ruler') {
                const snappedPos = getSnappedPoint(pos);
                currentPos = snappedPos;
                
                clearPreviewCanvas();
                // スナップインジケータを描画
                if (snappedPos !== pos) drawSnapIndicator(previewCtx, snappedPos); // 現在位置
                // (★) startPos がスナップされているかもチェック (isDrawing関係なく)
                if (getSnappedPoint(startPos) !== startPos) drawSnapIndicator(previewCtx, startPos); 

                // (★) isDrawing (ドラッグ中) の場合のみ、線プレビューを描画
                if (isDrawing) {
                    previewCtx.beginPath();
                    previewCtx.moveTo(startPos.x, startPos.y);
                    previewCtx.lineTo(currentPos.x, currentPos.y);
                    applyToolSettings(previewCtx);
                    previewCtx.setLineDash([5, 5]);
                    previewCtx.stroke();
                    previewCtx.setLineDash([]);
                }
                return; // 定規モードはここで終了
            }
            // ★★★ ここまで ★★★

            if (currentTool === 'compass') {
                if (compassDrawMode === 'circle') {
                    if (compassState === 'drawingArc' && isDrawing) {
                        currentPos = pos;
                        let radius;
                        if (isRadiusLocked) {
                            radius = lockedRadius;
                        } else {
                            // (★) 円モードでもスナップ
                            currentPos = getSnappedPoint(pos);
                            radius = Math.hypot(currentPos.x - compassCenter.x, currentPos.y - compassCenter.y);
                        }
                        
                        clearPreviewCanvas();
                        drawCross(previewCtx, compassCenter, 5, 'black');
                        drawRadiusLine(previewCtx, compassCenter, currentPos, 'red');
                        drawCircle(previewCtx, compassCenter.x, compassCenter.y, radius, 'red', 1, true);
                        if (currentPos !== pos) drawSnapIndicator(previewCtx, currentPos); // スナップ表示
                        return;
                    }

                } else {
                    if (compassState === 'centerSet') {
                        // (★) 弧モードの半径決めもスナップ
                        const snappedPos = getSnappedPoint(pos);
                        let previewRadius;
                        if (isRadiusLocked) {
                            previewRadius = lockedRadius;
                        } else {
                            previewRadius = Math.hypot(snappedPos.x - compassCenter.x, snappedPos.y - compassCenter.y);
                        }
                        clearPreviewCanvas();
                        drawCross(previewCtx, compassCenter, 5, 'black');
                        drawRadiusLine(previewCtx, compassCenter, snappedPos, 'red');
                        drawCircle(previewCtx, compassCenter.x, compassCenter.y, previewRadius, 'red', 1, true);
                        if (snappedPos !== pos) drawSnapIndicator(previewCtx, snappedPos); // スナップ表示
                        return; 
                    }
                    if (compassState === 'drawingArc' && isDrawing) {
                        // (★) 弧の終点もスナップ
                        currentPos = getSnappedPoint(pos);
                        clearPreviewCanvas();
                        
                        drawRadiusLine(previewCtx, compassCenter, startPos, 'red');
                        drawCircle(previewCtx, compassCenter.x, compassCenter.y, compassRadius, 'red', 1, true); 
                        if (getSnappedPoint(startPos) !== startPos) drawSnapIndicator(previewCtx, startPos); // 開始点スナップ表示
                        if (currentPos !== pos) drawSnapIndicator(previewCtx, currentPos); // 終点スナップ表示

                        let currentAngle = Math.atan2(currentPos.y - compassCenter.y, currentPos.x - compassCenter.x);
                        
                        let v1_x = startPos.x - compassCenter.x;
                        let v1_y = startPos.y - compassCenter.y;
                        let v2_x = currentPos.x - compassCenter.x;
                        let v2_y = currentPos.y - compassCenter.y;
                        let crossProduct = v1_x * v2_y - v1_y * v2_x;
                        let drawAsCounterClockwise = (crossProduct < 0);
                        
                        previewCtx.beginPath();
                        previewCtx.arc(compassCenter.x, compassCenter.y, compassRadius, compassStartAngle, currentAngle, drawAsCounterClockwise);
                        
                        previewCtx.strokeStyle = toolSettings.lineColor;
                        previewCtx.lineWidth = toolSettings.lineWidth;
                        previewCtx.lineCap = 'round';
                        previewCtx.lineJoin = 'round';
                        previewCtx.globalCompositeOperation = 'source-over';
                        
                        previewCtx.stroke();
                        return; 
                    }
                }
            }
            
            if (isDrawing) {
                currentPos = pos;
                switch (currentTool) {
                    case 'pen':
                        // (★) フリーハンドモードの時だけ描画
                        if (penDrawMode === 'freehand') {
                            mainCtx.lineTo(currentPos.x, currentPos.y);
                            mainCtx.stroke();
                        }
                        break;
                    case 'eraser':
                        mainCtx.lineTo(currentPos.x, currentPos.y);
                        mainCtx.stroke();
                        break;
                    case 'selectErase': {
                        // (★) selectSave は削除された
                        clearPreviewCanvas();
                        previewCtx.strokeStyle = '#007bff';
                        previewCtx.lineWidth = 1;
                        previewCtx.setLineDash([4, 2]);
                        const rect = getRect(startPos, currentPos);
                        previewCtx.strokeRect(rect.x, rect.y, rect.w, rect.h);
                        previewCtx.setLineDash([]);
                        break;
                    }
                }
            }
        }

        function handlePointerUp(e) {
            e.preventDefault();
            
            // (★) 点モードはDownで完結するので、Upでは何もしない
            if (currentTool === 'pen' && penDrawMode === 'point') {
                return;
            }
            
            if (currentTool === 'compass') {
                if (compassDrawMode === 'circle') {
                    if (compassState === 'drawingArc' && isDrawing) {
                        isDrawing = false;
                        // (★) 終点もスナップ
                        const pos = getSnappedPoint(getPosition(e));
                        let finalRadius;
                        
                        if (isRadiusLocked) {
                            finalRadius = lockedRadius;
                        } else {
                            finalRadius = Math.hypot(pos.x - compassCenter.x, pos.y - compassCenter.y);
                            compassRadius = finalRadius; 
                        }
                        
                        clearPreviewCanvas();
                        applyToolSettings(mainCtx); 

                        drawCircle(mainCtx, compassCenter.x, compassCenter.y, finalRadius, toolSettings.lineColor, toolSettings.lineWidth, false);
                        
                        compassState = 'idle';
                        compassCenter = null;
                        return;
                    }

                } else {
                    if (compassState === 'centerSet') {
                        return; 
                    }
                    if (compassState === 'drawingArc' && isDrawing) {
                        isDrawing = false;
                        clearPreviewCanvas();
                        applyToolSettings(mainCtx); 

                        if (!isRadiusLocked) {
                             // (★) 2点目(startPos)はDownでスナップ済み
                             compassRadius = Math.hypot(startPos.x - compassCenter.x, startPos.y - compassCenter.y);
                        }

                        // (★) 終点もスナップ
                        const pos = getSnappedPoint(getPosition(e));
                        let endAngle = Math.atan2(pos.y - compassCenter.y, pos.x - compassCenter.x);
                        
                        let v1_x = startPos.x - compassCenter.x;
                        let v1_y = startPos.y - compassCenter.y;
                        let v2_x = pos.x - compassCenter.x;
                        let v2_y = pos.y - compassCenter.y;
                        let crossProduct = v1_x * v2_y - v1_y * v2_x;
                        let drawAsCounterClockwise = (crossProduct < 0);

                        mainCtx.beginPath();
                        mainCtx.arc(compassCenter.x, compassCenter.y, compassRadius, compassStartAngle, endAngle, drawAsCounterClockwise);
                        mainCtx.stroke();
                        
                        compassState = 'idle';
                        compassCenter = null;
                        return;
                    }
                }
            }

            if (!isDrawing) return;
            isDrawing = false;
            
            clearPreviewCanvas(); 
            
            switch (currentTool) {
                case 'pen':
                case 'eraser':
                    mainCtx.closePath();
                    break;
                case 'ruler': {
                    // ★★★ (バグ修正) 指を離した(Up)位置でスナップする ★★★
                    const pos = getPosition(e);
                    const snappedPos = getSnappedPoint(pos);
                    currentPos = snappedPos; // 最終的な座標をスナップ

                    applyToolSettings(mainCtx);
                    mainCtx.beginPath();
                    mainCtx.moveTo(startPos.x, startPos.y); // startPosはDownの時点でスナップ済み
                    mainCtx.lineTo(currentPos.x, currentPos.y);
                    mainCtx.stroke();
                    break;
                }
                case 'selectErase': {
                    selectionRect = getRect(startPos, currentPos);
                    mainCtx.clearRect(selectionRect.x, selectionRect.y, selectionRect.w, selectionRect.h);
                    selectionRect = null;
                    break;
                }
                // (★) selectSave を削除
            }
        }
        
        function handlePointerLeave(e) {
             if (currentTool === 'compass') {
                 if (compassState !== 'idle') {
                     compassState = 'idle';
                     compassCenter = null;
                     isDrawing = false;
                     clearPreviewCanvas();
                     return;
                 }
             }
             if (isDrawing) {
                 handlePointerUp(e);
             }
        }

        // --- 8. 機能別ロジック (変更あり) -------------------------
        function clearMainCanvas() {
            const dpr = window.devicePixelRatio || 1;
            mainCtx.clearRect(0, 0, mainCanvas.width / dpr, mainCanvas.height / dpr);
        }

        function clearPreviewCanvas() {
            const dpr = window.devicePixelRatio || 1;
            previewCtx.clearRect(0, 0, previewCanvas.width / dpr, previewCanvas.height / dpr);
        }

        function drawCircle(ctx, x, y, radius, color, width, isPreview) {
            ctx.beginPath();
            if (radius <= 0) return;
            
            ctx.arc(x, y, radius, 0, Math.PI * 2);
            ctx.strokeStyle = color;
            ctx.lineWidth = width;
            if (isPreview) {
                ctx.setLineDash([5, 5]);
            }
            ctx.stroke();
            if (isPreview) {
                ctx.setLineDash([]);
            }
        }

        function saveFullCanvas() {
            try {
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                
                tempCanvas.width = mainCanvas.width;
                tempCanvas.height = mainCanvas.height;
                
                if (backgroundImage) {
                    tempCtx.drawImage(bgCanvas, 0, 0);
                } else {
                    tempCtx.fillStyle = '#ffffff';
                    tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
                }
                
                tempCtx.drawImage(mainCanvas, 0, 0);
                
                const dataURL = tempCanvas.toDataURL('image/png');
                downloadImage(dataURL, 'my-drawing.png');
                
            } catch (err) {
                console.error("保存に失敗しました:", err);
                alert("画像の保存に失敗しました。");
            }
        }

        // (★) saveSelection を削除

        function handleImageLoad(e) {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(event) {
                backgroundImage = new Image();
                backgroundImage.onload = function() {
                    redrawBgCanvas();
                }
                backgroundImage.src = event.target.result;
            }
            reader.readAsDataURL(file);
            
            e.target.value = null; 
        }

        // --- 9. ユーティリティ (ヘルパー関数) (変更あり) -----------------
        function getPosition(e) {
            const rect = previewCanvas.getBoundingClientRect();
            return {
                x: e.clientX - rect.left,
                y: e.clientY - rect.top
            };
        }
        
        function getRect(pos1, pos2) {
            const x = Math.min(pos1.x, pos2.x);
            const y = Math.min(pos1.y, pos2.y);
            const w = Math.abs(pos1.x - pos2.x);
            const h = Math.abs(pos1.y - pos2.y);
            return { x, y, w, h };
        }
        
        function downloadImage(dataURL, filename) {
            const link = document.createElement('a');
            link.href = dataURL;
            link.download = filename;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }
        
        function drawCross(ctx, point, size, color) {
            ctx.beginPath();
            ctx.moveTo(point.x - size, point.y);
            ctx.lineTo(point.x + size, point.y);
            ctx.moveTo(point.x, point.y - size);
            ctx.lineTo(point.x, point.y + size);
            ctx.strokeStyle = color;
            ctx.lineWidth = 1;
            ctx.setLineDash([]);
            ctx.stroke();
        }

        function drawRadiusLine(ctx, center, point, color) {
            ctx.beginPath();
            ctx.moveTo(center.x, center.y);
            ctx.lineTo(point.x, point.y);
            ctx.strokeStyle = color;
            ctx.lineWidth = 1;
            ctx.setLineDash([3, 3]);
            ctx.stroke();
            ctx.setLineDash([]);
        }

        // ★★★ (新規) 点を打つヘルパー関数 ★★★
        function drawPoint(ctx, pos) {
            ctx.beginPath();
            ctx.arc(pos.x, pos.y, POINT_RADIUS, 0, Math.PI * 2);
            ctx.fillStyle = toolSettings.lineColor; // (★) 点は「線色」で塗りつぶす
            ctx.fill();
        }

        // ★★★ (新規) スナップ先の点を検索する関数 ★★★
        function getSnappedPoint(pos) {
            for (const point of pointsHistory) {
                const distance = Math.hypot(pos.x - point.x, pos.y - point.y);
                if (distance < SNAP_DISTANCE) {
                    return point; // スナップした点の座標を返す
                }
            }
            return pos; // スナップしなかった場合は元の座標を返す
        }
        
        // ★★★ (新規) スナップインジケータ（青い円）を描画する関数 ★★★
        function drawSnapIndicator(ctx, pos) {
            ctx.beginPath();
            ctx.arc(pos.x, pos.y, SNAP_DISTANCE, 0, Math.PI * 2);
            ctx.strokeStyle = 'rgba(0, 0, 255, 0.5)'; // 半透明の青
            ctx.lineWidth = 1;
            ctx.setLineDash([2, 2]);
            ctx.stroke();
            ctx.setLineDash([]);
        }
        // ★★★ ここまで ★★★


        // (★★ 修正: Undo/Redoが点の履歴(pointsHistory)にも対応)
        function restoreCanvasState(dataURL, targetCtx, callback = null) {
            if (!dataURL) {
                const dpr = window.devicePixelRatio || 1;
                targetCtx.clearRect(0, 0, targetCtx.canvas.width / dpr, targetCtx.canvas.height / dpr);
                if (callback) callback();
                return;
            }

            const img = new Image();
            img.onload = function() {
                const dpr = window.devicePixelRatio || 1;
                targetCtx.clearRect(0, 0, targetCtx.canvas.width / dpr, targetCtx.canvas.height / dpr);
                targetCtx.drawImage(img, 0, 0, mainCtx.canvas.width / dpr, mainCtx.canvas.height / dpr);
                if (callback) callback();
            }
            img.src = dataURL;
        }

        function saveUndoState() {
            if (undoHistory.length >= MAX_UNDO_STEPS) {
                undoHistory.shift(); 
            }
            // (★) メインキャンバスの状態と、点の履歴を両方保存
            const mainData = mainCanvas.toDataURL();
            const pointsData = JSON.parse(JSON.stringify(pointsHistory)); // ディープコピー
            undoHistory.push({ main: mainData, points: pointsData });
        }

        function undoLastAction() {
            if (undoHistory.length > 0) {
                const stateToRestore = undoHistory.pop();
                // (★) キャンバスと点の履歴を両方復元
                pointsHistory = stateToRestore.points; 
                restoreCanvasState(stateToRestore.main, mainCtx);
            } else {
                console.log("これ以上元に戻せません。");
            }
        }
        
        // (★★ 修正: 状態保存/読込が点の履歴(pointsHistory)にも対応)
        function saveStateToLocalStorage() {
            if (!confirm('現在の描画状態をこのPCに保存しますか？（以前の保存データは上書きされます）')) return;

            try {
                const mainData = mainCanvas.toDataURL();
                localStorage.setItem(STORAGE_KEY_MAIN, mainData);
                
                const bgData = backgroundImage ? backgroundImage.src : null;
                if (bgData) {
                    localStorage.setItem(STORAGE_KEY_BG, bgData);
                } else {
                    localStorage.removeItem(STORAGE_KEY_BG); 
                }
                
                // (★) 点の履歴も保存
                localStorage.setItem(STORAGE_KEY_POINTS, JSON.stringify(pointsHistory));
                
                alert('保存しました。');

            } catch (e) {
                if (e.name === 'QuotaExceededError') {
                    alert('保存に失敗しました。\n描画内容（特に背景画像）が大きすぎて、ブラウザの保存容量(約5MB)を超えました。\n\n「7. 全画面保存(画像)」でファイルとして保存してください。');
                } else {
                    alert('保存に失敗しました: ' + e.message);
                }
            }
        }

        function loadStateFromLocalStorage() {
            try {
                const mainData = localStorage.getItem(STORAGE_KEY_MAIN);
                const bgData = localStorage.getItem(STORAGE_KEY_BG);
                // (★) 点の履歴も読み込み
                const pointsData = localStorage.getItem(STORAGE_KEY_POINTS);

                if (!mainData) {
                    alert('保存されたデータがありません。');
                    return;
                }

                if (!confirm('保存された作業を読み込みますか？（現在の描画内容とUndo履歴は失われます）')) return;

                undoHistory = []; 
                
                // (★) 点の履歴を復元
                pointsHistory = pointsData ? JSON.parse(pointsData) : [];
                
                if (bgData) {
                    backgroundImage = new Image();
                    backgroundImage.onload = function() {
                        redrawBgCanvas();
                        restoreCanvasState(mainData, mainCtx);
                    }
                    backgroundImage.src = bgData;
                } else {
                    backgroundImage = null;
                    redrawBgCanvas(); 
                    restoreCanvasState(mainData, mainCtx);
                }
                
                alert('読み込みました。');
            } catch (e) {
                 alert('読み込みに失敗しました: ' + e.message);
            }
        }

        function clearStateFromLocalStorage() {
            if (confirm('PCに保存した作業データを完全に消去しますか？（この操作は元に戻せません）')) {
                try {
                    localStorage.removeItem(STORAGE_KEY_MAIN);
                    localStorage.removeItem(STORAGE_KEY_BG);
                    localStorage.removeItem(STORAGE_KEY_POINTS); // (★) 点の履歴も消去
                    alert('保存データを消去しました。');
                } catch (e) {
                     alert('消去に失敗しました: ' + e.message);
                }
            }
        }
    </script>
</body>
</html>